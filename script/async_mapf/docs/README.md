# Async-MAPF ÂçèËÆÆÂêéÁ´ØÂºÄÂèë README

> Êú¨ÊñáËØ¥Êòé**Â¶Ç‰Ωï‰∏∫Ê°ÜÊû∂Êñ∞Â¢û‰∏ÄÁßçÂçèËÆÆÂêéÁ´Ø**„ÄÇÂú®Êú¨Ê°ÜÊû∂ÈáåÔºö
>
> - **AgentÔºàÂçèËÆÆ‰æßÂÆû‰æãÔºâ**ÔºöÊää‚ÄúÂçèËÆÆËøõÊù•ÁöÑ‰∫ã‰ª∂/Ê∂àÊÅØ‚ÄùÁøªËØëÂπ∂ËΩ¨ÂèëÁªôÊ†∏ÂøÉ AgentÔºà`core.agent_base.BaseAgent`Ôºâ„ÄÇ  
> - **CommAdapterÔºàÈÄö‰ø°ÈÄÇÈÖçÂô®Ôºâ**ÔºöÂè™Ë¥üË¥£‚ÄúÂ¶Ç‰ΩïÂèëÈÄÅ/Êé•Êî∂/Â∫èÂàóÂåñ/ÂèçÂ∫èÂàóÂåñ‚Äù„ÄÇ  
> - **RunnerÔºàË£ÖÈÖç/Ëµ∑ÊúçÔºâ**ÔºöÊää Network ‰∏éÂêÑ Agent ÁöÑÂçèËÆÆÊúçÂä°ÔºàASGIÔºâÂêØÂä®Ëµ∑Êù•ÔºåÂπ∂Â§ÑÁêÜ‰ºòÈõÖÈÄÄÂá∫„ÄÇ

---

## ÁõÆÂΩïÁªìÊûÑÔºàÁ∫¶ÂÆöÔºâ

script/async_mapf/
‚îú‚îÄ‚îÄ core/ # ‚òÖ ÁÆóÊ≥ï‰∏éÁΩëÁªúÂçèË∞ÉÔºàÂçèËÆÆÊó†ÂÖ≥ÔºåÂà´ÊîπÔºâ
‚îÇ ‚îú‚îÄ‚îÄ agent_base.py # BaseAgent
‚îÇ ‚îî‚îÄ‚îÄ network_base.py # NetworkBaseÔºàÂ∑≤ÊîØÊåÅÂÖ®ÈÉ®Âà∞ËææÂç≥Ëá™Âä®ÁªìÊùüÔºâ
‚îú‚îÄ‚îÄ protocol_backends/ # üîå ÊØèÁßçÂçèËÆÆ‰∏Ä‰∏™Â≠êÁõÆÂΩï
‚îÇ ‚îú‚îÄ‚îÄ a2a/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ adapters/a2a_comm_adapter.py
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ agents/mapf_worker_executor.py # ÂçèËÆÆ‰æß agent ÂÆû‰æã
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ agents/network_executor.py # ÂçèËÆÆ‰æß network ÂÖ•Âè£
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ runner.py # ‚òÖ A2A RunnerÔºàÂõ∫ÂÆöÊîæËøôÈáåÔºâ
‚îÇ ‚îî‚îÄ‚îÄ myproto/
‚îÇ ‚îú‚îÄ‚îÄ adapters/myproto_comm_adapter.py # ‚òÖ ‰Ω†ÂÆûÁé∞
‚îÇ ‚îú‚îÄ‚îÄ agents/agent_executor.py # ‚òÖ ‰Ω†ÂÆûÁé∞
‚îÇ ‚îú‚îÄ‚îÄ agents/network_executor.py # ÔºàÂèØÈÄâÔºöÂ¶ÇÊûúÂçèËÆÆÈúÄË¶ÅÔºâ
‚îÇ ‚îî‚îÄ‚îÄ runner.py # ‚òÖ Âª∫ËÆÆÊîæËøôÈáåÔºàÊàñÊîæ runners/Ôºâ
‚îú‚îÄ‚îÄ runners/
‚îÇ ‚îú‚îÄ‚îÄ base_runner.py # ‚òÖ ÈÄöÁî®ÁîüÂëΩÂë®Êúü/‰ºòÈõÖÈÄÄÂá∫Ôºà‰Ω†‰∏çÊîπÔºâ
‚îÇ ‚îú‚îÄ‚îÄ run_a2a.py # ÂÖ•Âè£Ôºöpython -m script.async_mapf.runners.run_a2a
‚îÇ ‚îî‚îÄ‚îÄ run_myproto.py # ‰Ω†ÁöÑÂçèËÆÆÂÖ•Âè£ÔºàÂèØÈÄâÔºå‰πüÂèØÁõ¥Êé• myproto/runner.pyÔºâ
‚îî‚îÄ‚îÄ config/
‚îú‚îÄ‚îÄ a2a.yaml
‚îî‚îÄ‚îÄ myproto.yaml


> Á∫¶ÂÆöË°•ÂÖÖÔºö  
> - **A2A ÁöÑ Runner Â∑≤Âõ∫ÂÆöË∑ØÂæÑ**Ôºö`script/async_mapf/protocol_backends/a2a/runner.py`„ÄÇ  
> - ÂÖ∂ÂÆÉ Runner ‰Ω†ÂèØ‰ª•Êîæ `protocol_backends/<proto>/runner.py`Ôºå‰πüÂèØ‰ª•Êîæ `script/async_mapf/runners/`Ôºå‰∫åËÄÖÊã©‰∏ÄÔºå**‰øùÊåÅ import Ë∑ØÂæÑ‰∏ÄËá¥**Âç≥ÂèØ„ÄÇ  
> - ÂêØÂä®/ÂÖ≥ÂÅú/‰ø°Âè∑Â§ÑÁêÜ/‚ÄúÂÖ®ÈÉ®Âà∞ËææÂç≥ÈÄÄÂá∫‚ÄùÔºåÁî± `runners/base_runner.py` Áªü‰∏ÄÂ§ÑÁêÜ„ÄÇ

---

## ‰∏â‰∏™‰Ω†ÈúÄË¶ÅÂÆûÁé∞/ÂÖ≥Ê≥®ÁöÑÁÇπ

### 1) CommAdapterÔºàÈÄö‰ø°ÈÄÇÈÖçÂô®Ôºâ

**ËÅåË¥£ÂîØ‰∏Ä**ÔºöÊää‚ÄúÊ°ÜÊû∂ÂØπË±°‚Äù‚Üî‚ÄúÂçèËÆÆËΩΩËç∑‚ÄùÂÅöÂ∫èÂàóÂåñ/ÂèçÂ∫èÂàóÂåñÔºåÂπ∂Áî®‰Ω†ÁöÑÂçèËÆÆÔºàHTTP/WS/ZMQ/‚Ä¶Ôºâ**ÂèëÂá∫Âéª/Êî∂ÂõûÊù•**„ÄÇ

Áªü‰∏ÄÊé•Âè£Ôºà‰∏é `core.comm.AbstractCommAdapter` ÂØπÈΩêÔºâÔºö
- `async def send(self, obj: Any) -> None`
- `async def recv(self) -> Any`
- `def recv_nowait(self) -> Any`
- `async def close(self) -> None`
- `def handle_incoming(self, raw) -> None`ÔºàÂçèËÆÆÊúçÂä°ÂÖ•Âè£ÊääÊî∂Âà∞ÁöÑÂéüÂßãÊ∂àÊÅØÂñÇÁªôËøôÈáåÔºâ

**Êé®ËçêÊ∂àÊÅØÂΩ¢Áä∂**ÔºàË∑®ÂçèËÆÆÂ∞ΩÈáèÁªü‰∏ÄÔºâÔºö

```json
// CONTROL
{"type":"CONTROL","payload":{"cmd":"START","agent_id":0}}

// MOVE_REQUESTÔºàÂπ∂ÂèëÊ®°ÂºèÔºâ
{"type":"MOVE_REQUEST","payload":{
  "agent_id":0,"move_id":"uuid","new_pos":[x,y],
  "eta_ms":120,"time_window_ms":50,"priority":1
}}

// MOVE_RESPONSE
{"type":"MOVE_RESPONSE","payload":{
  "agent_id":0,"move_id":"uuid","status":"OK|CONFLICT|REJECT",
  "reason":"...", "conflicting_agents":[2,3], "suggested_eta_ms":100
}}

// MOVE_FBÔºàÂÖºÂÆπÊóßÂºè MoveCmd ÁöÑÂèçÈ¶àÔºâ
{"type":"MOVE_FB","payload":{
  "agent_id":0,"success":true,"actual_pos":[x,y],"reason":""
}}

// CHAT
{"type":"CHAT","payload":{"src":0,"dst":1,"msg":"hi"}}

ÊúÄÂ∞èÁ§∫‰æãÔºà‰º™ÂÆûÁé∞ÔºåÁªô‰Ω†È™®Êû∂ÔºâÔºö

# script/async_mapf/protocol_backends/myproto/adapters/myproto_comm_adapter.py
import asyncio, json
from typing import Any, Dict, Optional
from script.async_mapf.core.comm import AbstractCommAdapter
from script.async_mapf.core.types import MoveCmd, MoveFeedback

class MyProtoCommAdapter(AbstractCommAdapter):
    def __init__(self, self_id: str, network_url: Optional[str] = None, agent_urls: Optional[dict] = None):
        self.self_id = self_id
        self.network_url = network_url
        self.agent_urls = agent_urls or {}
        self._rx_q = asyncio.Queue()

    async def connect(self):   ...
    async def disconnect(self):...
    async def close(self):     await self.disconnect()

    async def send(self, obj: Any) -> None:
        data = self._serialize(obj)
        # TODO: Áî®‰Ω†ÁöÑÂçèËÆÆÊää data ÂèëÂá∫ÂéªÔºàHTTP/WS/ZMQÁ≠âÔºâ

    async def recv(self) -> Any:      return await self._rx_q.get()
    def recv_nowait(self) -> Any:     return self._rx_q.get_nowait()

    def handle_incoming(self, raw: dict) -> None:
        obj = self._deserialize(raw)
        asyncio.create_task(self._rx_q.put(obj))

    def _serialize(self, obj: Any) -> Dict[str, Any]:
        if isinstance(obj, MoveCmd):
            return {"type":"MOVE_CMD","payload":{"agent_id":obj.agent_id,"new_pos":list(obj.new_pos)}}
        if isinstance(obj, MoveFeedback):
            return {"type":"MOVE_FB","payload":{
                "agent_id":obj.agent_id,"success":obj.success,"actual_pos":list(obj.actual_pos),"reason":""}}
        if isinstance(obj, dict): return obj
        return {"type":"UNKNOWN","payload":{"content":str(obj)}}

    def _deserialize(self, msg: Any) -> Any:
        if isinstance(msg, dict) and msg.get("type") == "MOVE_FB":
            return MoveFeedback(
                agent_id=msg["payload"].get("agent_id",0),
                success=bool(msg["payload"].get("success",False)),
                actual_pos=tuple(msg["payload"].get("actual_pos",[0,0])),
                reason=msg["payload"].get("reason","")
            )
        return msg


2) AgentÔºàÂçèËÆÆ agent ÂÆû‰æãÔºâ
ËøôÊòØÂçèËÆÆ‰æßÁöÑ agentÔºàÊØîÂ¶Ç A2A ÁöÑ MAPFAgentExecutorÔºâ„ÄÇ‰Ω†ÁöÑÂÆûÁé∞ÈúÄË¶ÅÂú®ÂçèËÆÆÊ°ÜÊû∂ÁöÑÂõûË∞ÉÈáåÔºö

Êî∂Âà∞ CONTROL.START ‚áí ÂêØÂä® core_agent.autonomous_loop()

Êî∂Âà∞ MOVE_RESPONSE ‚áí Ë∞É core_agent._handle_move_response(payload)

Êî∂Âà∞ MOVE_FB ‚áí ÊîæÂÖ• core_agent._recv_msgs_queue

ÂÖ∂ÂÆÉÂçèËÆÆ‰∫ã‰ª∂ÊåâÈúÄË∑ØÁî±Áªô core_agentÔºà‰æãÂ¶Ç CHATÔºâ

ÂÖ≥ÈîÆÁÇπÔºöÈÄö‰ø°Áî®‰Ω†ÁöÑ CommAdapterÔºõAgent ÂÆû‰æãÂè™ÂÅö‚ÄúÂçèËÆÆ‰∫ã‰ª∂ ‚Üí Ê†∏ÂøÉ Agent‚ÄùÁöÑÊ°•Êé•„ÄÇ

# script/async_mapf/protocol_backends/myproto/agents/agent_executor.py
import asyncio, json
from typing import Any, Dict
from script.async_mapf.core.agent_base import BaseAgent as CoreAgent
from ..adapters.myproto_comm_adapter import MyProtoCommAdapter

class MyProtoAgentExecutor:
    """Protocol-facing agent instance. Bridges protocol events to CoreAgent."""
    def __init__(self, cfg: Dict[str, Any], global_cfg: Dict[str, Any], agent_id: int, network_url: str, output=None):
        self.agent_id = agent_id
        self.output = output
        self.adapter = MyProtoCommAdapter(str(agent_id), network_url=network_url)
        asyncio.create_task(self.adapter.connect())
        self.core_agent = CoreAgent(
            agent_id=agent_id,
            adapter=self.adapter,
            config={"agent_config": cfg, "model": global_cfg.get("model"), "protocol": "myproto"}
        )

    async def on_message(self, payload: str | Dict[str, Any]):
        data = json.loads(payload) if isinstance(payload, str) else payload
        t, p = data.get("type"), data.get("payload", {})

        if t == "CONTROL" and p.get("cmd") == "START":
            if not hasattr(self, "_loop") or self._loop.done():
                self._loop = asyncio.create_task(self.core_agent.autonomous_loop())
            return {"ok": True}

        if t == "MOVE_RESPONSE":
            await self.core_agent._handle_move_response(p)
            return {"ok": True}

        if t == "MOVE_FB":
            await self.core_agent._recv_msgs_queue.put(self.adapter._deserialize(data))
            return {"ok": True}

        # ÂèØÊâ©Â±ïÔºöCHAT„ÄÅMOVE_CMD(Êóß) Á≠â
        return {"ok": False, "reason": "ignored"}

3) NetworkExecutorÔºàÂèØÈÄâÔºâ
Ëã•‰Ω†ÁöÑÂçèËÆÆ‰πüÈúÄË¶Å‰∏Ä‰∏™ÁΩëÁªúÁ´ØÂÖ•Âè£ÔºàÂÉè A2A ÁöÑ NetworkBaseExecutorÔºâÔºå‰Ω†ÈúÄË¶ÅÔºö

Êî∂Âà∞ MOVE_REQUEST ‚áíÔºàÂ∏¶ÈîÅÔºâË∞ÉÁî® network_base._apply_move_concurrent(...)ÔºåÂπ∂Âõû MOVE_RESPONSE

Ë∞ÉÁî® network_base.set_a2a_send_callback(self.send_to_agent)ÔºåÊää‚ÄúÂõûÂèëÁªô Agent ÁöÑÊñπÊ≥ï‚ÄùÊ≥®ÂÜåËøõÂéªÔºàNetworkBase ‰ºöÂú®ÂπøÊí≠ START/STOP Êó∂Áî®ÂÆÉÔºâ

Âπ∂ÂèëÂÆâÂÖ®Ôºö‰øÆÊîπ world_state Êó∂ËØ∑ async with network_base._move_lock:„ÄÇ

4) RunnerÔºàË£ÖÈÖç/Ëµ∑ÊúçÔºâ
Runner ÁªßÊâø RunnerBaseÔºåÂè™ÈúÄÂÆûÁé∞‰∏§‰ª∂‰∫ãÔºö

build_network_app(network_coordinator, agent_urls)ÔºöËøîÂõû Network ‰æß ASGI Â∫îÁî®

build_agent_app(agent_id, agent_cfg, port, network_base_port)ÔºöËøîÂõû Agent ‰æß ASGI Â∫îÁî®

ÂÖ∂ÂÆÉ‰∫ãÊÉÖÔºàÂä†ËΩΩ YAML„ÄÅÂä®ÊÄÅÁ´ØÂè£„ÄÅËµ∑ÊâÄÊúâÊúçÂä°„ÄÅÁõëÂê¨ Ctrl+C„ÄÅÂÖ®ÈÉ®Âà∞ËææÂç≥Ëá™Âä®ÈÄÄÂá∫„ÄÅ‰ºòÈõÖÂÖ≥ÂÅúÔºâÈÉΩÁî± RunnerBase Â§ÑÁêÜÂ•Ω‰∫Ü„ÄÇ

ÊúÄÂ∞è Runner Á§∫‰æãÔºàÁî® FastAPI Ê®°Êãü HTTP ÂçèËÆÆÔºâÔºö

# script/async_mapf/protocol_backends/myproto/runner.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import asyncio, time
from typing import Dict, Any
from script.async_mapf.runners.base_runner import RunnerBase
from .agents.agent_executor import MyProtoAgentExecutor

class MyProtoRunner(RunnerBase):
    def build_network_app(self, network_coordinator, agent_urls: Dict[int, str]):
        app = FastAPI(title="MAPF Network (myproto)")

        # Êèê‰æõ‰∏Ä‰∏™ Agent -> Network ÁöÑÂÖ•Âè£
        @app.post("/msg")
        async def on_msg(req: Request):
            data = await req.json()
            t, p = data.get("type"), data.get("payload", {})

            if t == "MOVE_REQUEST":
                from script.async_mapf.core.concurrent_types import ConcurrentMoveCmd
                if not hasattr(network_coordinator, "_move_lock"):
                    network_coordinator._move_lock = asyncio.Lock()

                cmd = ConcurrentMoveCmd(
                    agent_id=p["agent_id"], new_pos=tuple(p["new_pos"]),
                    eta_ms=p.get("eta_ms", 100), time_window_ms=p.get("time_window_ms", 50),
                    move_id=p.get("move_id",""), priority=p.get("priority",1)
                )

                exec_ts = int(time.time()*1000)
                async with network_coordinator._move_lock:
                    ok, conflicts = network_coordinator._apply_move_concurrent(cmd, exec_ts)

                resp = {"type":"MOVE_RESPONSE","payload":{
                    "agent_id":cmd.agent_id,"move_id":cmd.move_id,
                    "status":"OK" if ok else ("CONFLICT" if conflicts else "REJECT"),
                    "reason":"Move successful" if ok else ("Conflict" if conflicts else "Move failed"),
                    "conflicting_agents":conflicts, "suggested_eta_ms":100 if conflicts else None
                }}

                # ÈÄöËøáÂ∑≤Ê≥®ÂÜåÁöÑÂõûË∞ÉÊääÂìçÂ∫îÈÄÅÂõû Agent
                if hasattr(network_coordinator, "_a2a_send_callback"):
                    await network_coordinator._a2a_send_callback(cmd.agent_id, resp)

            return JSONResponse({"ok": True})

        # Ê≥®ÂÜå‚ÄúÂ¶Ç‰ΩïÂõûÂèëÁªô Agent‚ÄùÁöÑÂõûË∞ÉÔºàËøôÈáåÁ§∫ËåÉÁî® HTTP ÂÆ¢Êà∑Á´ØÔºå‰Ω†Ëá™Ë°åÂÆûÁé∞Ôºâ
        async def send_to_agent(agent_id: int, message: dict):
            # TODO: Áî®‰Ω†ÁöÑÂçèËÆÆÊää message ÈÄÅÂà∞ agentÔºà‰æãÂ¶Ç POST Âà∞ agent ÁöÑ /msgÔºâ
            pass

        network_coordinator.set_a2a_send_callback(send_to_agent)
        return app

    def build_agent_app(self, agent_id: int, agent_cfg: Dict[str, Any], port: int, network_base_port: int):
        app = FastAPI(title=f"MAPF Agent {agent_id} (myproto)")
        network_url = f"http://localhost:{network_base_port}"

        executor = MyProtoAgentExecutor(agent_cfg, self.sim_config, agent_id, network_url)

        @app.post("/msg")  # Network -> Agent
        async def on_msg(req: Request):
            data = await req.json()
            result = await executor.on_message(data)
            return JSONResponse(result)

        return app

A2A ‰∏ìÁî® Runner ÁöÑ‰ΩçÁΩÆÂõ∫ÂÆö‰∏∫ script/async_mapf/protocol_backends/a2a/runner.pyÔºà‰Ω†Â∑≤ÁªèÊúâ‰∫ÜÔºâ„ÄÇ
ÂÖ∂ÂÆÉÂçèËÆÆÂª∫ËÆÆÂêåÊ†∑ÊîæÂú®ÂØπÂ∫îÂçèËÆÆÁõÆÂΩï‰∏ãÁöÑ runner.pyÔºõËã•‰Ω†Êõ¥ÂÄæÂêëÈõÜ‰∏≠ÊîæÂà∞ script/async_mapf/runners/ ‰πüÂèØÔºå‰ΩÜÊ≥®ÊÑè import Ë∑ØÂæÑ„ÄÇ

ËøêË°å
A2AÔºàÂ∑≤Â∞±‰ΩçÔºâÔºö

bash
python -m script.async_mapf.runners.run_a2a
‰Ω†ÁöÑÂçèËÆÆÔºàmyprotoÔºâÔºöÊñ∞Âª∫ runners/run_myproto.py ÊàñÁõ¥Êé• protocol_backends/myproto/runner.py ÂÜô mainÔºåÁ§∫‰æãÔºö

python
# script/async_mapf/runners/run_myproto.py
import asyncio
from pathlib import Path
from script.async_mapf.protocol_backends.myproto.runner import MyProtoRunner

if __name__ == "__main__":
    cfg = Path("script/async_mapf/config/myproto.yaml")
    asyncio.run(MyProtoRunner(cfg).run())
ÁÑ∂ÂêéÔºö

python -m script.async_mapf.runners.run_myproto

ÂºÄÂèëË¶ÅÁÇπ & ÊéíÈöúÊ∏ÖÂçï
Âä°ÂøÖÂõûÂåÖÔºöMOVE_REQUEST Êó†ËÆ∫ÊàêÂäü/Â§±Ë¥•/ÂºÇÂ∏∏ÔºåÈÉΩË¶ÅÂõû MOVE_RESPONSEÔºåÂê¶Âàô Agent ‰ºöÁ≠âÂæÖÊÇ¨ÊåÇ„ÄÇ

Âπ∂ÂèëÂÆâÂÖ®ÔºöNetwork Á´Ø‰øÆÊîπ world_state Ë¶Å async with network_base._move_lock:„ÄÇ

Ëá™Âä®ÁªìÊùüÔºöNetworkBase Âú®ÊØèÊ¨°Áä∂ÊÄÅÊõ¥Êñ∞Âêé‰ºö _maybe_trigger_completionÔºõRunnerBase Â∑≤ÊääÂÆåÊàêÂõûË∞ÉÊé•Âà∞ shutdown_eventÔºå‰ºö‰ºòÈõÖÈÄÄÂá∫ÔºåÊó†ÈúÄ‰Ω†ÂÜçÂÜô„ÄÇ

Êó•ÂøóÔºöÂ∞ΩÈáèÁî® script.async_mapf.utils.log_utils Áªü‰∏Ä loggerÔºõÂÖ≥ÈîÆ‰∫ã‰ª∂ÂèØ‰ª• log_network_event(...)„ÄÇ

Ê∂àÊÅØÂΩ¢Áä∂Áªü‰∏ÄÔºöÈÅµÂÆà‰∏äÈù¢ÁöÑ JSON ÁªìÊûÑÔºåÂèØ‰ª•ÊûÅÂ§ßÂáèÂ∞ëËÉ∂Ê∞¥‰ª£Á†Å„ÄÇ

Ë∑ØÂæÑ/Á∫¶ÂÆöÔºöA2A ÁöÑ Runner Ë∑ØÂæÑÂõ∫ÂÆöÔºõÂÖ∂ÂÆÉÂçèËÆÆ Runner ÊîæÂì™ÈÉΩË°åÔºå‰ΩÜ‰øùËØÅ import ‰∏ÄËá¥„ÄÇ

FAQ
Q: Agent Èáå LLM Ê≤°ÂàùÂßãÂåñÂÆåÂ∞± STARTÔºå‰ºöÊÄéÊ†∑Ôºü
A: RunnerBase ‰ºöÂª∂Êó∂ÂπøÊí≠ STARTÔºà‰Ω†ÁöÑÂêéÁ´Ø‰πüÂèØ‰ª•ÂÅöÁ±ª‰ººÂ§ÑÁêÜÔºâ„ÄÇAgent ‰æß‰πüÂèØÂú® CONTROL.START Êî∂Âà∞Êó∂Ëá™Ê£ÄÂπ∂Âª∂ËøüÂêØÂä®„ÄÇ

Q: ÊàëÂè™ÊÉ≥Áî®Êú¨Âú∞ÂÜÖÂ≠òÈòüÂàóÂÅö‰∏™ÂÅáÁöÑÂçèËÆÆË∑ëÈÄö CIÔºü
A: ÂèÇËÄÉ protocol_backends/dummyÔºàÊàñÁÖßÁùÄ‰∏äÈù¢ÁöÑ CommAdapter È™®Êû∂ÔºåÁõ¥Êé•Áî® asyncio.Queue Âç≥ÂèØÔºâ„ÄÇ

Q: ÊàëÈúÄË¶ÅËá™ÂÆö‰πâ‚ÄúÂÖ®ÈÉ®Âà∞Ëææ‚ÄùÁöÑÂà§ÂÆöÔºü
A: network_base.py Â∑≤ÊîØÊåÅÁõÆÊ†áÂà§ÂÆö‰∏éÂÆåÊàêÂõûË∞É„ÄÇÂøÖË¶ÅÊó∂Âú® YAML Âä† stop_on_all_goals: falseÔºåËá™Ë°åÊéßÂà∂ÁªìÊùüÊó∂Êú∫ÔºåÂπ∂Âú® Runner Ë∞É shutdown()„ÄÇ

ÂêéÁª≠Â∑•‰Ωú / Â∑≤Áü•ÈôêÂà∂ÔºàWIPÔºâ
Êó•ÂøóËêΩÁõòÊú™ÂÆåÊàê

ÂΩìÂâç‰∏ªË¶ÅÊòØÁªàÁ´ØÊâìÂç∞Ôºõlog_utils/LogManager Âà∞Êñá‰ª∂ÁöÑËêΩÁõòÈìæË∑Ø‰ªçÊúâÈóÆÈ¢òÔºàÈÉ®ÂàÜÊ®°Âùó logger Êú™Ê≠£Á°ÆÊåÇËΩΩ handlerÔºåA2A ‰∫ã‰ª∂‰πüÊú™Áªü‰∏ÄËêΩÁõòÔºâ„ÄÇ

ËÆ°ÂàíÔºöÊ¢≥ÁêÜÁªü‰∏ÄÁöÑ logging.Logger Â±ÇÁ∫ßÔºåÊ∑ªÂä† RotatingFileHandlerÔºåÁ°Æ‰øù script/async_mapf/logs/ ‰∏ãÊåâ run-id/Êó•ÊúüÂàÜÁõÆÂΩïÂÜôÂÖ•ÔºåÂπ∂‰øÆÂ§çÈáçÂ§çÊó•Âøó/‰∏¢Êó•ÂøóÈóÆÈ¢ò„ÄÇ

Metrics Êú™ÈõÜÊàê

metrics/ Ê®°ÂùóÂ∞öÊú™Êé•ÂÖ•ËøêË°åÊó∂ÊµÅÁ®ãÔºõÊú™ËÆ∞ÂΩïÊØèÊ≠•Êó∂Âª∂„ÄÅÂÜ≤Á™ÅÁéá„ÄÅÂêûÂêêÁ≠âÊåáÊ†á„ÄÇ

ËÆ°ÂàíÔºöÂú® NetworkBase._apply_move[_concurrent] ‰∏é Agent ÂÖ≥ÈîÆË∑ØÂæÑÊâìÁÇπÔºå‰ΩøÁî® MetricsRecorder ÂÆöÊúü flushÔºõÊèê‰æõÁÆÄÂçïÁöÑÁ¶ªÁ∫øËÅöÂêà‰∏éÂèØËßÜÂåñËÑöÊú¨„ÄÇ

Agent Âç°Ê≠ªÂà§ÂÆö & Á¥ßÊÄ•ÈÄÄÂá∫Áº∫Â§±

ÁõÆÂâçÊ≤°ÊúâÂøÉË∑≥/ËøõÂ∫¶ watchdogÔºõÊüê‰∏™ Agent ‰∏≠ÈÄîÊåÇËµ∑Êàñ LLM Ë∂ÖÊó∂‰ºöÂØºËá¥Êï¥‰ΩìÂÅúÊªû„ÄÇ

ËÆ°ÂàíÔºö‰∏∫ÊØè‰∏™ Agent/ÁΩëÁªúÂõûË∑ØÂä†ÂÖ•ÂøÉË∑≥‰∏é‚ÄúÊó†ËøõÂ±ïË∂ÖÊó∂‚ÄùÊ£ÄÊµãÔºàÂ¶Ç N ÁßíÊó†ÂùêÊ†áÂèòÂåñ / Êó†ÂìçÂ∫îÂç≥ÈáçËØïÊàñÊ†áËÆ∞Â§±Ë¥•ÔºâÔºåÊîØÊåÅ‰∏ÄÈîÆ EMERGENCY_STOP ÂπøÊí≠‰∏é Runner Á∫ßÂà´Âº∫Âà∂ÈÄÄÂá∫„ÄÇ

Ctrl+C Áõ¥Êé•ÈÄÄÂá∫Êú™ÂÆåÂñÑ

Windows/WSL Á≠âÁéØÂ¢É‰∏ã‰ø°Âè∑Â§ÑÁêÜ‰∏ç‰∏ÄËá¥Ôºå‰∏™Âà´Âú∫ÊôØ Ctrl+C ‰∏çËÉΩÂç≥Êó∂„ÄÅ‰ºòÈõÖÂú∞ÈÄÄÂá∫ÔºàÈúÄÁ≠â uvicorn/ÂêéÂè∞‰ªªÂä°Ëá™Ë°åÁªìÊùüÔºâ„ÄÇ

ËÆ°ÂàíÔºöÂÆåÂñÑ RunnerBase._install_signal_handlersÔºåÂØπ uvicorn/server/background tasks Áªü‰∏ÄË∂ÖÊó∂ÂèñÊ∂àÔºåÂøÖË¶ÅÊó∂Êèê‰æõÂèØÈÖçÁΩÆÁöÑ‰∫åÊÆµÂºèÂº∫ÊùÄÔºàË∂ÖÊó∂ÂêéË∞ÉÁî® os._exit(1) ‰Ωú‰∏∫ÊúÄÂêéÂÖúÂ∫ïÔºâ